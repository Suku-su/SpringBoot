# Jvm

整体结构：

![image-20250630182613532](jvm.assets/image-20250630182613532.png)

　　![img](https://images2015.cnblogs.com/blog/616953/201602/616953-20160221214401030-1375432400.png)

## 类加载子系统：

### 启动类装载器（Java虚拟机实现的一部分）

### 用户自定义类装载器（Java程序的一部分）

类装载子系统负责==定位==和==导入==二进制class文件，并且保证导入类的正确性，==为类变量分配==并初始==化内存==，以及帮助解析符号引用。

类加载器的装载顺序：

-  ==装载== -- 查找并装载类型的二进制数据

- ==连接== -- 执行验证，准备，以及解析（可选），连接分为如下三个步骤

  　　　　==验证== -- 确保被导入类型的正确性

  　　       ==准备== -- 为类变量分配内存，并将其初始化为默认值

  　　　　==解析== -- 把类型中的符号引用转换为直接引用

- ==初始化== -- 把类变量初始化为正确初始值

  ![image-20250630184357693](jvm.assets/image-20250630184357693.png)



类加载的分类

![image-20250630185822833](jvm.assets/image-20250630185822833.png)

==双亲委派==机制：

作用：避免类的==重复加载==、防止核心的==api被篡改==

机制：

先看有没有被加载过，加载过就返回对象

没有就看有没有父亲，有就看父亲有没有加载过，加载过就返回对象，没有向上委托

没有就看有没有爷爷，有就看看爷爷有没有加载过，加载过就返回对象，没有向上委托

都没有就自己加载





运行时数据区

![image-20250630192338958](jvm.assets/image-20250630192338958.png)

### 程序计数器

1、是物理寄存器的抽象实现

2、用来记录执行的下一条指令的地址

3、他是程序控制流的指示器，循环、if else、异常处理、线程恢复等都依赖与程序计数器

4、解释器工作时通常是通过他来获取下一条需要执行的字节码指令的

5、他是唯一一个在jvm规范里面没有规定任何的outofmemoryError情况的区域

## java方法栈

1. java虚拟机是线程私有的，它的生命周期和线程相同。

2. 每执行一个发方法创建一个栈帧，里面存储了存储局部变量表、操作数栈、动态链接、方法出口。

3. ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/faeec1b7ac47ae7178eab450982ba528.png)

   解析栈帧：

   局部变量表：是用来存储我们临时8个==基本数据类型==（byte，short、long、int、float、double、boolean）、==对象引用地址==、==returnAddress==类型。（returnAddress中保存的是return后要执行的字节码的指令地址。）
   操作数栈：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去
   动态链接：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，存储链接的地方。
   出口：出口是什呢，出口正常的话就是return 不正常的话就是抛出异常落

   （存储局部变量、以及操作数栈（怎么操作然后给存到变量里面，以及需要体哦啊用的其他方法，返回后的地址））

   **一个方法调用另一个方法，会创建很多栈帧吗？**
   答：会创建。如果一个栈中有动态链接调用别的方法，就会去创建新的栈帧，栈中是由顺序的，一个栈帧调用另一个栈帧，另一个栈帧就会排在调用者下面

   **栈指向堆是什么意思？**
   栈指向堆是什么意思，就是栈中要使用成员变量怎么办，栈中不会存储成员变量，只会存储一个应用地址，堆中的数据等下讲

   **递归的调用自己会创建很多栈帧吗？**
   递归的话也会创建多个栈帧，就是一直排下去

   

   

   

   

   



## 本地方法栈

本地方法栈很好理解，他很栈很像，只不过方法上带了 native 关键字的栈字
它是虚拟机栈为虚拟机执行Java方法（也就是字节码）的服务
native关键字的方法是看不到的，必须要去oracle官网去下载才可以看的到，而且native关键字修饰的大部分源码都是C和C++的代码。
同理可得，本地方法栈中就是C和C++的代码



## Java内存结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e697a0dc7137c68de0ea57cc67fffacf.png)























































# csdn链接

```
https://blog.csdn.net/weixin_43122090/article/details/105093777?ops_request_misc=elastic_search_misc&request_id=90c6ab2e3fb00c3e9fdd847da823900f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105093777-null-null.142^v102^pc_search_result_base3&utm_term=jvm&spm=1018.2226.3001.4187
```

