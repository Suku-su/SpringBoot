# HashMap

**键值对的存储**：每个键（`key`）对应一个值（`value`）。

**快速查询**：通过哈希算法进行快速查询，`HashMap` 查找、插入、删除操作的时间复杂度在理想情况下是 O(1)。

**允许 null 值**：`HashMap` 允许键和值为 `null`，但键只能有一个 `null`。

## HashMap 的底层结构

HashMap 底层是基于数组 + 链表 + 红黑树的组合实现的，主要包括以下几部分：

数组（Node<K,V>[] table）：HashMap 的核心是一个数组，数组中的每个元素是一个链表或树的头节点，称为“桶”。
链表：当多个键通过哈希碰撞（Hash Collision）映射到同一个位置时，这些键会以链表的形式存储。
红黑树：当链表长度超过一定阈值（默认是8）时，链表会转换成红黑树，以提高查询效率。

## HashMap 的工作原理

**存储过程**：

1. 通过hash计算出哈希值，然后调用indexFor（）方法来查找应该存放在哪一个数组
2. 如果该位置没有元素，就直接存入（然后看数组是否达到了75%的负载因子）
3. 先判断是否相同，不同就存入（可能是链表也可能是红黑树）
4. 查看当前（如果为链表）链表是否超过8，超过就转为红黑树

**扩容**：

`HashMap` 的初始容量默认为 16，负载因子为 0.75。当数组元素达到容量的 75% 时（即 `threshold = capacity * load factor`），`HashMap` 会自动扩容，将数组容量翻倍，并重新计算每个元素的位置。

**查找过程**：

通过键的哈希值确定索引位置。

若数组中对应位置存在链表或红黑树，则根据键的 `equals()` 方法遍历链表或树，找到对应的键值对

#### HashMap 的重要特性

哈希冲突：即两个或多个不同的键计算出相同的哈希值，这会导致多个键映射到数组的同一个索引。通过链表或红黑树解决冲突问题。
红黑树优化：当链表长度超过 8 时，链表会转化为红黑树，查找效率从 O(n) 提高到 O(log n)。
线程不安全：HashMap 是非线程安全的。如果需要在多线程环境下使用 HashMap，需要通过同步机制（如 Collections.synchronizedMap()）或使用线程安全的类（如 ConcurrentHashMap）。

#### HaspMap底层源码分析

`HashMap` 是 Java 中常用的数据结构，它以**键值对**的形式存储数据，并通过**哈希表**的形式快速查找键对应的值。为了更深入地理解 `HashMap` 的实现机制，我们需要从它的底层源码出发，分析其数据结构、核心方法和优化策略。

##### 1. **基本数据结构**

在 HashMap 中，最核心的两个数据结构是：

数组：Node<K,V>[] table，这是 HashMap 的底层存储结构，所有键值对都存储在数组中。
链表和红黑树：当出现哈希冲突时，多个键值对会被存储在同一个数组位置（桶）中，最初使用链表实现，当链表长度超过一定阈值时（8），会转换为红黑树。

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // 指向下一个节点
}
```

负载因子：0.75

插入流程：

![img](https://i-blog.csdnimg.cn/direct/5c06258225a64c839d4c5c53e7b02eb9.png)





查找流程：

![img](https://i-blog.csdnimg.cn/direct/8b976d03e34c475a82ff51d53bc63dd1.png)
